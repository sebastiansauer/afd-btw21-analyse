---
title: "Analyse des AfD-Wahlerfolgs bei der Bundestagswahl 2021"
author: "Sebastian Sauer"
date: "11/12/2021"
dpi: 300
output: 
  rmdformats::readthedown:
    #toc: true
    number_sections: true
    
---

```{r global-knitr-options, include=FALSE}
  knitr::opts_chunk$set(
    fig.pos = 'H',
  fig.asp = 0.618,
  fig.align='center',
  fig.width = 5,
  out.width = "100%",
  fig.cap = "", 
  fig.path = "chunk-img/",
  dpi = 300,
  # tidy = TRUE,
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  fig.show = "hold")
```


# Hintergrund


Die Bundestagswahl ist ein zentrales Ereignis für die Öffentlichkeit in Deutschland. Vor der hohen Relevanz dieses Ereignisses stellt sich die Frage, welche Faktoren die Ursache (oder zumindest Prädiktoren) der Wahlentscheidungen der Bürgerinnen und Bürger sind. Ist beispielsweise die Höhe der Arbeitslosigkeit in einem Wahlkreis ausschlaggebend, dass die eine oder andere Partei gewählt wird?

Die Analyse des Wahlerfolgs der Partei "Alternative für Deutschland" (AfD) ist von besonderem Interesse, da ein Teil ihrer Wählis und Vertretis offenbar die Grundsätze deutscher Politik hinterfragt und vielleicht entgegensteht. [So hat das Bundesamt für Verfassungsschutz Teilorganisationen der AfD zum Verdachtsfall für Rechtsextremismus eingestuft](https://www.verfassungsschutz.de/SharedDocs/kurzmeldungen/DE/2019/fachinformation-zu-teilorganisationen-der-afd.html).

Die Relevanz der Analyse extremistischer Bewegungen begründet sich mit einem Blick in die deutsche Geschichte: Die (deutsche) Geschichte des 20. Jahrhunderts zeigt, dass rechtsextreme Bewegungen das Potenzial für katastrophale Entwicklungen und schlimmste Verbrechen haben. 

Ziel und Gegenstand dieses Workshops ist es nicht, eine Meinung oder ein Urteil über die Einschätzung des Verfassungsschutzes oder der AfD zu treffen. Vielmehr ist vor dem genannten Hintergrund die Analyse, warum bzw. unter welchen Randbedingungen die AfD Stimmen auf sich zieht, von höchstem gesellschaftlichem Interesse. 



# Hinweise

Ziel dieser Analyse ist es, grundlegende Methoden der Datenanalyse für eine angewandte Forschungsfrage bzw. eine Forschungsfrage von allgemeinem Interesse, vorzustellen bzw. einzuüben.

Es handelt sich um eine Analyse mit rein didaktischem Ziel.

Es sind keinerlei politische Aussagen mit dieser Analyse verbunden.


# Forschungsfragen


1. Wie groß ist der AfD-Stimmenanteil, aggregiert pro Bundesland und Deutschlandweit? Wie verteilt sich der Stimmenanteil der AfD?

2. Wie hängt der Wahlerfolg der AfD mit ökonomopolitischen Indikatoren wie Arbeitslosigkeitsquote und Ausländeranteil zusammen?




# Vorbereitung

## R-Pakete


```{r}
library(tidyverse)
library(sf)  # Geo-Visualisierung
library(rstatix)  # Deskriptive Statistiken
library(corrr)  # Korrelationsmatrizen
library(gt)  # HTML Tabellen
library(rstanarm)  # Bayes-Modellierung
library(tictoc)
```



# Daten aufbereiten

## Ökonomopolitische Strukturdaten


### Daten einlesen

Die Strukturdaten sind vom [Bundeswahlleiter](https://bundeswahlleiter.de/bundestagswahlen/2021/strukturdaten.html) zu beziehen; über [diesen Link](https://bundeswahlleiter.de/dam/jcr/b1d3fc4f-17eb-455f-a01c-a0bf32135c5d/btw21_strukturdaten.csv) kommt man zu den Daten (CSV-Format).


Die Variablennamen sind [hier](https://bundeswahlleiter.de/bundestagswahlen/2021/strukturdaten/beschreibung.html) erklärt.

```{r}
d_str_file <- "data/btw21_Strukturdaten.csv"

d_str <- read_delim(d_str_file,
                    delim = ";", 
                    escape_double = FALSE,
                    locale = locale(decimal_mark = ",",
                                    grouping_mark = "."),
                    trim_ws = TRUE,
                    skip = 8) 
```

Hier sind die Namen der Spalten:

```{r}
names(d_str)
```


Es ist vielleicht praktisch, die Spaltennamen für spätere Verwendung in einer Textdatei abzuspeichern:

```{r}
d_str_names <-
  tibble(
    var_name = names(d_str),
    ) %>% 
  mutate(id = row_number())

write_csv(d_str_names, "objects/d_str_names.csv")
```



### Daten aufbereiten

Die Spaltennamen sind etwas unhandlich. Formulieren wir lieber prägnanter:


```{r}
names(d_str) <- paste0("V",1:ncol(d_str))

d_str2 <-
  d_str %>% 
  select(state = V1,
         area_nr = V2,
         area_name = V3,
         for_prop = V8,
         pop_density = V9,
         pop_move = V11,
         income = V36,
         unemp = V47) 
```


Sichern wir diese Daten in eine Datei:


```{r}
write_csv(d_str2, file = "objects/d_str2.csv")
```


## Wahlergebnisse

### Daten einlesen

Die Daten sind vom [Bundeswahlleiter](https://bundeswahlleiter.de/bundestagswahlen/2021/ergebnisse/opendata.html#39734920-0eaf-4633-8858-ae792d5d610b) zu beziehen. Unter [diesem Link](https://www.bundeswahlleiter.de/bundestagswahlen/2021/ergebnisse/opendata/csv/kerg2.csv) kommt man direkt zur CSV-Datei.

Eine Erklärung zu den Variablen findet sich [hier](https://bundeswahlleiter.de/dam/jcr/f801a6d7-e51f-4804-baa4-dacec780704d/btw21_dsb_kerg2.pdf).


```{r}
elec_results_file <- "https://www.bundeswahlleiter.de/bundestagswahlen/2021/ergebnisse/opendata/csv/kerg2.csv"

elec_results <- read_delim(elec_results_file,
                    delim = ";", 
                    escape_double = FALSE,
                    locale = locale(decimal_mark = ",",
                                    grouping_mark = "."),
                    trim_ws = TRUE,
                    skip = 9
                    ) 
```


### Daten aufbereiten

Konzentrieren wir uns auf die Zweitstimme, da die bei der BTW die entscheidende ist.

```{r}
elec_results2 <- 
  elec_results %>% 
  select(Gebietsart, Gebietsnummer, Gebietsname, UegGebietsart, UegGebietsnummer, Gruppenart, Gruppenname, Stimme, Prozent, DiffProzentPkt) %>% 
  filter(Gruppenname == "AfD") %>% 
  filter(Stimme == 2)
```


```{r}
elec_results2 <- 
  elec_results2 %>% 
  mutate(Gebietsname = ifelse(Gebietsname == "Bundesgebiet",
                              "Deutschland",
                              Gebietsname))
```



Sichern wir diese Daten in eine Datei:

```{r}
write_csv(elec_results2, file = "objects/elec_results2.csv")
```




# Einfache, univariate Ergebnisse


## Mittelwert des AfD-Wahlerfolgs 

### ... über alle Bundesländer

Achtung! Alle Bundesländer werden gleich gewichtet!

```{r}
elec_results2 %>% 
  filter(Gebietsart == "Land") %>% 
  summarise(AfD_mean = mean(Prozent))
```

### ... über Deutschland

```{r}
elec_results2 %>% 
  filter(Gebietsart == "Bund") %>% 
  summarise(AfD_mean = mean(Prozent)) 
```


### ... über Wahlkreise


```{r}
elec_results2 %>% 
  filter(Gebietsart == "Wahlkreis") %>% 
  summarise(AfD_mean = mean(Prozent, na.rm = T))
```



## Wahlerfolg der AfD nach Bundesländern


```{r}
elec_results2 %>%
  filter(Gebietsart == "Land") %>% 
  select(Gebietsname, Prozent) %>% 
  mutate(Gebietsname = as.factor(Gebietsname)) %>% 
  ggplot(aes(x =  reorder(Gebietsname, Prozent), 
             y = Prozent)) +
  geom_col() +
  coord_flip() +
  labs(title = "AfD-Zweitstimmenanteil bei der BTW 21",
       caption = "Die Linie zeigt den Mittelwert für ganz Deutschland",
       y = "Anteil in Prozent",
       x = "Bundesländer") +
  geom_hline(yintercept = 10.1) +
  annotate("label", x = "Hamburg", y = 10,
           label = "Mittelwert",
           size = 2) +
  geom_text(aes(label = round(Prozent)),
            nudge_y = -1,
            color = "white",
            size = 2)
```





# Daten zusammenführen (join)

## Erster Versuch

```{r}
d <- 
  d_str2 %>% 
  full_join(elec_results2, by = c("area_name" = "Gebietsname"))
```

Einige Zeilen lassen sich nicht zusammenführen. Schauen wir diese uns näher an:

```{r}
d %>% 
  filter(str_detect(area_name, "nsgesamt"))  # Ohne "I"!
```

Es sind die Bundesländer, deren `area_name` "Land insgesamt", jeweils, lautet.

Diese Felder müssen wir wohl umbenennen.

Bundesländer - plus der Bund als Ganzes - haben eine ID, die mit 9 beginnt, was für sonstige Einheiten nicht der Fall ist:


```{r}
d_leander <- 
d %>% 
  select(area_nr, area_name, state) %>% 
  filter(str_detect(area_nr, "^9")) %>% 
  mutate(area_name = state) %>% 
  select(-state)
```


Da die Länder auch noch noch eine andere Gebietsnummer haben in der Datei mit den Strukturdaten, fügen wir noch die Gebietsnummer aus `elec_results2` hinzu:

```{r}
d_laender2 <-
  d_leander %>% 
  left_join(elec_results2 %>% select(Gebietsname, Gebietsnummer), by = c("area_name" = "Gebietsname"))
```

Sieht dann so aus:

```{r}
d_laender2
```



## Zweiter Versuch

Jetzt fügen wir die korrigierten Landesnamen und -nummern zu `d_str2` hinzu: 

```{r}
d_str3 <-
  d_str2 %>% 
  left_join(d_laender2, by = "area_nr")
```


`area_name.y` ist aktuell nur mit Landesnamen (plus Bund) gefüllt. Ergänzen wir also die `NA`s mit den Namen der Wahlbezirke. Die andere Spalte `area_name.x` brauchen wir dann nicht mehr.

```{r}
d_str4 <- 
  d_str3 %>% 
  mutate(area_name.y = ifelse(is.na(area_name.y),
                              area_name.x,
                              area_name.y)) %>% 
  select(-area_name.x) %>% 
  rename(area_name = area_name.y)
```

Das Gleiche machen wir mit `area_nr`: 

```{r}
d_str5 <-
  d_str4 %>% 
  mutate(area_nr = ifelse(is.na(Gebietsnummer),
                                area_nr,
                                Gebietsnummer))
```



```{r}
d_str5 %>% 
  slice_head(n=20) 
```

Scheint zu passen.

```{r}
d <-
  d_str5 %>% 
  left_join(elec_results2, by = c("area_nr" = "Gebietsnummer"))
```

```{r}
dim(d)
```

316 ist eine gute Zahl: 

- 299 Wahlbezirke
- 16 Länder
- 1 Bund


## Check


Prüfen wir, ob es noch fehlende Werte nach dem Join gibt:

```{r}
d %>% 
  filter(is.na(Gruppenname), is.na(Prozent)) %>% 
  select(area_name, area_nr, Prozent) %>% 
  nrow()
```




Zählen wir die Anzahl der Wahleinheiten nach Art:

```{r}
d %>% 
  group_by(Gebietsart) %>% 
  count()
```

Das sieht gut aus.



## Geo-Daten


Die Geodaten sind ebenfalls erhältlich beim [Bundeswahlleiter](https://bundeswahlleiter.de/bundestagswahlen/2021/wahlkreiseinteilung/downloads.html).

Die Geodaten zur Visualisierung der Wahlkreise werden im sog. "Shape-Format" (.shp) geliefert.

```{r}
geo_file <- "data/btw21_geometrie_wahlkreise_shp/Geometrie_Wahlkreise_20DBT.shp"
```


Einlesen:

```{r}
wahlkreise_shp <- st_read(geo_file)
```

Hilfe zu `st_read()` findet sich [hier](https://www.rdocumentation.org/packages/sf/versions/1.0-3/topics/st_read) oder auf der Dokumentation zum R-Paket `sf` (simple feature).



Plotten:

```{r}
wahlkreise_shp %>%
  ggplot() +
  geom_sf()
```

Der Aufbau des Datensatzes ist aufgeräumt:

```{r}
glimpse(wahlkreise_shp)
```


## Geo-Daten joinen


```{r}
d2 <-
  d %>% 
  mutate(area_nr = as.integer(area_nr)) %>% 
  full_join(wahlkreise_shp, by = c("area_nr" = "WKR_NR"))
```



# Geo-Vis


## AfD-Anteil

```{r}
d2 %>% 
  ggplot() +
  geom_sf(aes(fill = Prozent,
              geometry = geometry))
```


Verschönern:


```{r}
d2 %>% 
  ggplot() +
  geom_sf(aes(fill = Prozent,
              geometry = geometry),
          color = NA) +
  scale_fill_viridis_c() +
  theme_void() +
  labs(title = "Anteil der Zweitstimmen für die AfD",
       subtitle = "Bundestagswahl 2021",
        fill = "Anteil AfD-Zweitstimmen") +
  theme(legend.position = "bottom")
```



Ein paar Wahlkreise haben entweder nicht erwischt, oder es gibt keine Daten.


## Ausländeranteil

```{r}
d2 %>% 
  ggplot() +
  geom_sf(aes(fill = for_prop,
              geometry = geometry),
          color = NA) +
  scale_fill_viridis_c() +
  theme_void()
```



## Arbeitslosigkeit


```{r}
d2 %>% 
  ggplot() +
  geom_sf(aes(fill = unemp,
              geometry = geometry),
          color = NA) +
  scale_fill_viridis_c() +
  theme_void()
```


## Bevölkerungsdichte


```{r}
d2 %>% 
  ggplot() +
  geom_sf(aes(fill = pop_density,
              geometry = geometry),
          color = NA) +
  scale_fill_viridis_c() +
  theme_void()
```

Oder vielleicht lieber Bevölkerungsdichte in der Log2-Skala?



```{r}
d2 %>% 
  ggplot() +
  geom_sf(aes(fill = log2(pop_density),
              geometry = geometry),
          color = NA) +
  scale_fill_viridis_c() +
  theme_void()
```


So kommen die Unterschiede optisch deutlich besser zum Tragen. 

Zur Erinnerung: +1 auf der Log2-Skala entspricht einer Multiplikation mit 2 auf der Rohskala. Die Log2-Skala zählt also "Verdopplungsschritte".


# EDA


##  Prädiktoren des AfD-Wahlerfolgs



### Ausländeranteil


```{r}
d2 %>% 
  filter(Gebietsart == "Wahlkreis") %>% 
  select(Prozent, for_prop) %>% 
  ggplot() +
  aes(x = for_prop, y = Prozent) +
  geom_point(alpha = .7) +
  geom_smooth()
```


Interessant! Ein einfacher linearer Trend liegt nicht vor.
Vielleicht sehen wir eher zwei, unterschiedliche Cluster?

Cluster 1 ist geprägt von hohem Ausländeranteil und Cluster 2 von geringem. 
In beiden Clustern ist der Zusammenhang negativ. 
Allerdings ist dieser Zusammenhang deutlich stärker ausgeprägt für Cluster 1.

### Ausländeranteil nach Bundesland

Wenn wir diese Analyse aufteilen nach Bundesländern, sehen wir viellicht klarer.



```{r fig.asp = 1}
d2 %>% 
  filter(Gebietsart == "Wahlkreis") %>% 
  select(Prozent, for_prop, state) %>% 
  ggplot() +
  aes(x = for_prop, y = Prozent, color = state) +
  geom_point(alpha = .7) +
  geom_smooth(method = "lm") +
  facet_wrap(~ state) +
  scale_y_continuous(limits = c(0, 40)) +
  theme(legend.position = "none")
```


Es scheint sich in jedem Bundesland ein negativer, linearer Zusammenhang zu zeigen.
Es sei denn, der AfD-Anteil ist sehr gering, dann wird der Zusammenhang schwach, also eine Bodeneffekt.


## Bivariate Korrelationen

```{r}
d2 %>% 
  select(Prozent, for_prop, unemp, income, pop_density) %>% 
  cor_mat()
```


```{r}
d2 %>% 
  select(Prozent, for_prop, unemp, income, pop_density) %>% 
  cor_mat() %>% 
  cor_plot()
```


Das Kreuz zeigt wohl eine Korrelation nahe Null an.


Die Korrelationsmatrix im langen Format:

```{r}
d2 %>% 
  select(Prozent, for_prop, unemp, income, pop_density) %>% 
  cor_mat() %>% 
  cor_gather() %>% 
  filter(cor != 1) %>% 
  filter(var1 == "Prozent") %>% 
  arrange(cor) %>% 
  gt() %>% 
  fmt_number(where(is.numeric), decimals = 2)
```

Je mehr Ausländer, oder auch je mehr Einkommen, desto weniger wird AfD gewählt. Die Arbeitslosigkeit steht fast nicht in einem (linearen) Zusammenhang mit dem AfD-Wahlerfolg.



# Modellierung

## Daten aufbereiten

Alle Prozessorkerne nutzen:

```{r}
options(mc.cores = parallel::detectCores())
```


Daten aufbereiten:

```{r}
d3 <-
  d2 %>% 
  mutate(Prozent_z = scale(Prozent),
         for_prop_z = scale(for_prop),
         unemp_z = scale(unemp)) %>% 
  select(Prozent_z, state, for_prop_z, unemp_z, Gebietsname) %>% 
  filter(state != "Deutschland")
```


## Model 1

### Modell berechnen

Modell berechnen:

```{r}
tic()
m1 <- 
  stan_glm(Prozent_z ~ state + unemp_z + for_prop_z,
               data = d3,
           refresh = 0
           )
toc()
```

Modellergebnisse:

```{r}
m1
```


Modellparameter visualisieren:


```{r}
plot(m1)
```


### Modellergebnisse interpretieren

Fast alle Modellparameter werden vom Modell als relevant angesehen - 
mit Ausnahme des Koeffizienten für Mecklenburg-Vorpommern.

Die stärksten Koeffizienten finden wir für Sachsen und Thüringen. 
Das sind auch die Länder mit dem höchsten Wahlerfolg für die AfD.
